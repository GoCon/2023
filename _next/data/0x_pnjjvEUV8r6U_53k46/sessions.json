{"pageProps":{"sessionsAndSpeakers":[{"id":"483590","title":"タクシーアプリ『GO』高速マッチングシステムで実践したGoチューニングテクニック","roomName":"Room A","sessionId":"A1-SP","description":"タクシーアプリ『GO』は、タクシー車両とのリアルタイムな位置情報連携と高度な配車ロジックによって、アプリユーザーと近くのタクシーを呼べるアプリです。\r\nそのコアとなる、タクシーとユーザーとのマッチングアルゴリズムの処理を、より全体最適を実現できるアーキテクチャーとするために、マイクロサービスとして切り出しました。\r\nこのサービスではアルゴリズムの実現だけではなく、これまでのサービス品質を損なわないように、低レイテンシと高可用化を目指して多くのチューニングを行いました。\r\nそれらの取り組みを紹介します。\r\n\r\nセッションで話すこと\r\n- 高速マッチングシステムのアーキテクチャー\r\n- ボトルネック調査の取り組み\r\n- 低レイテンシのための並列・非同期化と、そのエラーハンドリングなどの実装方法\r\n- 高可用化のための取り組み\r\n\r\nセッションで話さないこと\r\n- マッチングアルゴリズムの詳細","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"Atsushi Morimoto","tagLine":"GO株式会社 AI技術開発部プロダクトグループ","profilePicture":"https://sessionize.com/image/a3c1-400o400o2-hsySZPnoonanE9LV7XiScS.png"}},{"id":"483977","title":"無理なく始めるGoでのユニットテストの並行化戦略","roomName":"Room A","sessionId":"A2-SP","description":"テストの並列実行によって、テストにかかる時間の削減が期待できます。標準パッケージのtestingには、並列実行をサポートする仕組みが用意されていますが、その導入や適切な使い方には課題があります。\r\n\r\n例としては、以下のようなトピックです。\r\n・一定規模以上のアプリケーションのテストをすべて対応させるのが大変なこと\r\n・テストを並列実行することで新たなバグが発生すること\r\n・データベースと接続するテストの並行化\r\n\r\nこのセッションでは、これらの問題を解消するために作成したツールや私が所属しているチームでの事例の紹介を交え、テストの並行化を無理なく導入・運用する方法についてお話しします。","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"Shoki Hata","tagLine":"株式会社カンム","profilePicture":"https://sessionize.com/image/750b-400o400o2-KYbgVjHNMPEVLVgNoKkKgw.jpg"}},{"id":"437718","title":"よくわかるThe Go Memory Model - 行間を図解で埋め尽くす","roomName":"Room A","sessionId":"A3-L","description":"[アウトライン]\r\n\r\n- 並行処理の難しさと逐次一貫モデルの破綻\r\n- 観測可能性とhappens-before関係\r\n- Go1.19メモリーモデルとsync/atomicパッケージ\r\n\r\n[セッション紹介文]\r\n\r\nThe Go Memory Modelというドキュメントを知っていますか？これはGo言語で並行処理を行ったときにどのようなことが保証され、または保証されないかを記述したものです。広い意味ではGo言語仕様書の一部ともいえる、基本的で重要なドキュメントです。\r\n\r\nしかし、The Go Memory Modelはごく短いドキュメントであるにも関わらず、Go言語仕様書よりも読解が難しいドキュメントです。それはメモリーモデルという分野のもつ複雑な文脈によります。この分野は複数のプログラム言語に跨って発展してきました。必要な知識のある場所もGoのドキュメントに閉じていません。\r\n\r\nこのような文脈がThe Go Memory Modelの中では説明しきれないため、行間が広くてハイコンテキストな、「わかる人が読めばわかる」ドキュメントになっているのです。\r\n\r\n一方で、The Go Memory Modelの内容はグラフによる図示に非常に適しています。そのため、The Go Memory Modelを読解するには、具体的なプログラムを考え、たくさんの図を描きながら広い行間を埋めていくことが有効です。\r\n\r\nこのセッションでは、そのたくさんの図をお見せしながら、The Go Memory Modelが何を言っているのかを具体的なプログラムに即して解説します。Go1.19でThe Go Memory Modelに追加されたsync/atomicの仕様記述についてもスッキリ理解できるようになるでしょう。\r\n\r\n","sessionLevel":"advanced","sessionType":"Long Talk(40min)","speaker":{"fullName":"Nobishii","tagLine":"未入力","profilePicture":"https://sessionize.com/image/9fb0-400o400o2-nCxiwtjrR1JwsyCWXCjdP3.png"}},{"id":"439751","title":"Fun with Slices","roomName":"Room B","sessionId":"B3-L","description":"Slices can be seen in almost every Go program, but many developers are still unware of how they exactly work.\r\n\r\nOn the surface we might think they are simple constructs that allows us to handle multiple elements of a single type, but they are more than just a collection.\r\n\r\nSpecially for people new to Go, slices can be a source of pain because of the behaviors it possess that you wouldn't expect from a traditional dynamic array or list.\r\n\r\nIn this session we are going to do a deep dive on the slice type, starting from arrays and slice declaration syntax, slicing operations, copying, resizing and its surprising (or not) side effects.\r\n\r\nThe session will be composed most of code examples using the playground, with an eventual dive into the compiler source code to see the relevant bits of slice implementation.","sessionLevel":null,"sessionType":"Long Talk(40min)","speaker":{"fullName":"Daniela Petruzalek","tagLine":"Principal Architect at JPMC | Google Developer Expert","profilePicture":"https://sessionize.com/image/b05f-400o400o2-4RWiEd2HdfW1LrdrkkrE92.JPG"}},{"id":"439765","title":"「Go Style Guide」から学んだ可読性の高いコードの書き方","roomName":"Room A","sessionId":"A4-S","description":"みなさん、Googleが公開したGo Style Guideは読みましたか？\r\n\r\nソフトウェア開発は継続的な活動であり、一般的に複数人で行うことが多いです。\r\n継続的に複数人で開発を行う場合、自分が書いたコードを他人が読んだり修正したりすることが非常に多いです。\r\nそのため可読性の高いコードを書くことは開発効率やメンテナンス性の向上に役立ちます。\r\n\r\nGoはシンプルな言語ですが、どのように書くべきか悩むことが全くないわけではなく、そのような時従来はEffective Go/Uber Go Style Guide/OSSコード等を参考にどのように書くか決めていたと思います。\r\nこれらに加え、昨年末にGoogleからGo Style Guideが公開されました。GO Style Guide では従来よりも幅広い範囲について解説がされています。(例えば、テストの書き方については非常に詳しく記載されています)\r\nこのトークでは「実際に開発しているプロダクトではどのように書いていたか」や「読んだ内容を元に現在はどう書いているか」を交えつつ「Go Style Guide」の内容から学んだことをご紹介します。","sessionLevel":"beginner","sessionType":"Short Talk(20min)","speaker":{"fullName":"Natsumi Kojima","tagLine":"ANDPAD Inc.","profilePicture":"https://sessionize.com/image/7161-400o400o2-sq7tgMNEejmD7hJRy3bLej.jpg"}},{"id":"439669","title":"AIと静的解析を組み合わせたコード生成の仕組みをつくる","roomName":"Room B","sessionId":"B4-S","description":"Go言語を使ったプロジェクトにおいて、開発生産性を上げていくためにコード生成の仕組みに取り組んでいる組織は少なくないと思います。実際に、例えばREST APIであればswaggerなどのスキーマファイルからoapi-codegen[1]などを使用してGoのhttpハンドラー周りのコードを生成したり、DBのスキーマ定義をもとにxo[2]などを使用してGoのDB操作周りのコードを生成するケースをよく見ることがあります。また、より簡易的にはgotests[3]などを使用して、スニペットのようにGoのテストの枠組みを生成するケースもあると思います。\r\n\r\nしかし、静的解析だけによるコード生成は基本的には何らかの決まりきったルールによってのみコードが生成されていくモノだと考えています。\r\n\r\n今回の発表では、jennifer[4]を用いたAST構築による静的解析ベースのコード生成をまずは出発点として、そこに大規模言語モデルのような機械学習を活用し、より柔軟性を持たせた形でのコード生成の仕組みを作ろうと思います。\r\n\r\nそうすることで、usecaseやentityといった事業ドメインに近くほとんどのケースでコード生成を適用できないような領域に対しても、少しずつコード生成が適用されていく様子をお伝えできたらと考えています。また、ルールベースでは生成することが難しい、ユニットテストにおけるテストケース自体についてもコード生成がどこまで適用出来るのかをお伝えすることができたらと思います。\r\n\r\nまた、そういったコード生成の仕組みをどのように普段の開発プロジェクトに投入して行って、チームとしての開発生産性を高めているかという話にも触れようと考えています。\r\n\r\njenniferやGoのコードの静的解析の中身や仕組み自体についてはこの発表ではあまり触れず、そちらについては既に素晴らしい発表等[5]があるので参照していただく形にして、\r\n\r\nこの発表では\r\n\r\n1. 静的解析を使ったコード生成のおさらい (20%)\r\n2. AI/機械学習を使ったコード生成の方法・仕組みと、実際にどこまで適用できるのか (60%)\r\n3. 実際の開発プロジェクトに投入する上で、工夫している点（20%)\r\n\r\nのような構成にして、静的解析のみによるコードの生成から一歩進んだ部分に焦点を当てたものにすることで、この発表内で収まるものと考えています。\r\n\r\n大規模言語モデル周りの技術がまさに日進月歩なため、発表時点までに実装内容の方針が変更されることが想定されますが、現段階ではGPTモデルに対して既存の実装をもとにAPIを通して生成したいコードを複数パターン要求し、それを開発者が適宜選択しつつ、エラーを修正したり細かい調整をするようなやり方がプロジェクトに適切にフィットしていると感じています。\r\n\r\n[1] https://github.com/deepmap/oapi-codegen\r\n[2] https://github.com/xo/xo\r\n[3] https://github.com/cweill/gotests\r\n[4] https://github.com/dave/jennifer\r\n[5] GoConference 2022 であれば https://gocon.jp/2022spring/ja/sessions/b8-sや https://gocon.jp/2022spring/ja/sessions/b3-lなど","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"稲田 修也","tagLine":"Supreme System, Midas Capital","profilePicture":"https://sessionize.com/image/6857-400o400o2-NuXsaFLPUyQQnS1GrcXNVM.jpg"}},{"id":"434938","title":"多様なプロトコルと駆動モデルをサポートするIoTゲートウェイの開発と運用の知見","roomName":"Room A","sessionId":"A5-SP","description":"Goで書かれたIoTゲートウェイを提供・運用し続けて得られた知見を紹介していきたいと思います。\r\n\r\nMODE はエンタープライズ向けのクラウド型の IoT プラットフォームを提供しています。多くあるクラウドサービスとすこし違い、ソフトウェアが動く場所としてふたつの主要な場所があります。一般的なクラウドのサーバ上と、もうひとつは実際の現場で動くデータを収集したり機器を制御する IoT ゲートウェイ上です。\r\n\r\nIoTゲートウェイが収集するデータは、様々なタイプの駆動モデルや通信プロトコルを利用する機器から収集されることが想定されます。例えばプロトコルだけでも EnOcean, BLE, Serial, TCP/UDP, OBD-II, BACNet, NMEA など様々です。また、各機器の駆動モデルも同期的・非同期的、状態を持つもの・持たないものなど多様にあります。\r\n\r\nIoTゲートウェイをひとつのコード基盤上でいかに低コストで安定的に開発していくか・運用していくかはプラットフォーム提供者として大きな課題となります。本セッションでは汎用 IoT ゲートウェイ開発と運用を通じて得られた Go の知見を紹介していきたいと考えています。","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"Takeshi Shinoda","tagLine":"MODE, Inc.","profilePicture":"https://sessionize.com/image/c127-400o400o2-JpJZinEci6a4bw4dz3HVN5.png"}},{"id":"439845","title":"次なるrouterパッケージ選定のしざまと決め手について","roomName":"Room A","sessionId":"A6-SP","description":"先日Goの軽量routerの代表格であるgorilla/mux擁するGorilla Web Toolkitがアーカイブされました。\r\n私たちのチームで開発しているGoのWeb APIはすべてgorilla/muxに依存しており、対応を迫られました。\r\nフォークしてチーム内でメンテナンスを行うことも考えられましたが、チームの規模的に無理があり他のパッケージへ移行する必要がありました。\r\nそこで今回の発表では移行時に行った他のパッケージの比較検討や最終的な決断の意思決定について話します。\r\nこの発表を通してパッケージの選定基準などについて、同じくrouterや外部パッケージを移行したい方の手助けになれば幸いです。","sessionLevel":"Intermediate","sessionType":"Short Talk(20min)","speaker":{"fullName":"Ren Ogaki","tagLine":"BASE, Inc.","profilePicture":"https://sessionize.com/image/f50f-400o400o2-BT5ELzTwJV8cfAWKFqULTn.png"}},{"id":"440154","title":"Go/Cgoで映像・音声のリアルタイム処理をやるまでの道のり","roomName":"Room A","sessionId":"A7-L","description":"Goでマルチメディアのデータをリアルタイムに処理したい場合に、標準パッケージを使用したプログラムにおいて十分なパフォーマンス目標に到達するにはなかなか困難な道のりがあります\r\n\r\n例えば画像データ処理における行列演算のCPU命令はGoから直接実行することはできず、Cgoを利用することになります\r\nCgoを経由してC/C++で書かれたCPU命令を多用するコードは可読性/保守性の面からも品質の維持が難しいものがあります\r\n\r\n本セッションでは、私の所属する会社でストリーミングサーバ上でリアルタイムに映像/音声処理を行うために、Goのエコシステムを活かしつつ高速な処理を実現するために行ってきたこと、どういった変遷を経てCgoを用いながら保守性の高いコードを維持できるようにしたか、halide-langとGoの連携など、リアルタイム処理を実現するまでの過程と手法を紹介します","sessionLevel":"Intermediate","sessionType":"Long Talk(40min)","speaker":{"fullName":"Yusuke Hata","tagLine":"株式会社ミラティブ, インフラ・ストリーミンググループ MGR","profilePicture":"https://sessionize.com/image/d0a9-400o400o2-Ww6RiacdhS9dbHP5L6Z1L3.jpg"}},{"id":"417398","title":"どうしてもcgoから逃げられなくなったあなたに知ってほしいcgoの使い方入門","roomName":"Room B","sessionId":"B7-L","description":"\"Cgo is not Go\"という格言があるように、C/C++の資源をGoから呼び出す行為というのは、シンプルなビルドや優れたパフォーマンスといったGoの良さを殺してしまうため基本的には避けるのが主流です。Goコンパイラ・ランタイム自身もバージョン1.4を最後にC言語への依存を撤廃しており、なるべくpure Goで実装しようという潮流は今後も変わることはないでしょう。\r\nしかし、世の中から「C言語で作られたリソースをGoで作ったアプリケーション内で利用しなければいけない」という場面が完全になくなることはありません。筆者もそのような要件からどうしても逃げられなかった経験を持つ一人です。\r\n繰り返しになりますが、cgoをあえて使うという選択肢は一般的なものではありません。それゆえに、\"Hello, World!\"程度の小規模な利用の仕方であればThe Go Blog等に情報がありますが、ある程度の規模のC/C++ライブラリをcgoを用いてGoのコードから呼び出せるようにするためのノウハウはウェブ上には現状皆無といって良いかと思います。\r\n本セッションでは、「C言語は学生時代に少しだけ触ったことがある、C++は一切経験なし」というバックグラウンドから、C/C++製の静的ライブラリを組み込んでGoのプロダクトを作ることになったときの筆者の試行錯誤の体験をお話しようかと思います。","sessionLevel":"beginner","sessionType":"Long Talk(40min)","speaker":{"fullName":"Saki H","tagLine":"クラウドエンジニア","profilePicture":"https://sessionize.com/image/0b38-400o400o2-WiWnH8BdwFnDQFqvY9szS1.png"}},{"id":"437359","title":"Dive into testing package ~ Part of Fuzzing Test ~","roomName":"Room A","sessionId":"A8-S","description":"去年Go Conference mini 2022 Autumn IN SENDAIでgo testとtestingパッケージの仕組みについて発表しました。\r\nこのセッションではtesting packageはtesting.Tの*testing.T.Logや*testing.T.ParallelなどUnit Testで共通して使われる内容に絞り、Goにおけるtestの全体像とその仕組みを追うようなセッションでした。\r\n\r\n本セッションではGo Conference mini 2022 Autumn IN SENDAIの発展編としてGo1.18から登場したFuzzing Testの仕組みや内部実装について深掘ります。Fuzzing Testは機能としてもまだGoの公式から出ているチュートリアルのようにどのように動かすかについての詳細は日本語、英語含めて多くありますが、Goが提供するFuzzin Testの内部的な実装や仕組みに踏み込んでいる内容は少ないです。そのため、今後Fuzzing Testの仕組みを知りたい方や、興味はあるがまだソースコードリーディングできていない方に向けて発表します。\r\n\r\nまずFuzzing Testを読むにあたり必要なtesting packageとgo testの仕組みについて知ることから始めます。これにより今後ご自身でtesting packageのFuzzing Test以外の仕組みを見たい際に1人でソースコードリーディングができるようになります。\r\n\r\nその後主題でもあるFuzzing Testについて発表します。Fuzzingで与えられるCorpusは内部でどのように処理が行われているのか、go testで渡されたoptionがFuzzing Testにどのような影響を与えているかについてGoの公式から出ているFuzzingのチュートリアルを基に1つずつ見ていきます。\r\n\r\n本セッションを通して視聴者の方はGoのFuzzing Testの仕組みはもちろんのこと、go testやtesting packageについても理解を深めることができます。","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"Takuma Shibuya","tagLine":"Cyber Agent","profilePicture":"https://sessionize.com/image/2891-400o400o2-KZpjHT7KUEbge4dULsU8gD.png"}},{"id":"431265","title":"EchoやGinはなぜ速いのか？Goで高速なHTTP routerを作るコツ","roomName":"Room B","sessionId":"B8-S","description":"今回は主にパフォーマンスの観点から高速なHTTP routerを作るに当たっての紹介をする予定です。\r\nここでのHTTP routerは、static routing/path param routingの2つの機能を提供することを前提とします。\r\n\r\nセッションの構成は以下の4つになります。\r\n- 高機能なHTTP routerを提供する際に、なぜsync.Poolを使うのか\r\n- path params routingにおいて文字列を高速で扱う\r\n- 関数呼び出しの回数を減らすことでの高速化\r\n- 上の3つを踏まえて、有名なOSSのHTTP routerが速い理由をまとめます\r\n\r\n時間が余れば、sync.Poolを使う/使わないときや、文字列をナイーブに扱ったときのベンチマーク比較を紹介しようと思います。","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"Keisuke Nakamura","tagLine":"DMM.com,エンジニア","profilePicture":"https://sessionize.com/image/28cc-400o400o2-wdz8RzSA4Pew4rxjHmXwSR.jpeg"}},{"id":"438961","title":"Escape Analysis in Go: Understanding and Optimizing Memory Allocation","roomName":"Room A","sessionId":"A9-S","description":"Proposal\r\nTitle:\r\n\"Escape Analysis in Go: Understanding and Optimizing Memory Allocation\"\r\nAbstract:\r\nGo is a popular programming language known for its performance and efficiency. However, in order to achieve maximum performance, it's important to understand how Go manages memory. One of the key concepts in this area is escape analysis, a technique used by the Go runtime to determine when and where to allocate memory on the heap. In this talk, we will cover the basics of escape analysis in Go, including how it works, common pitfalls to watch out for, and techniques for optimizing memory allocation in your Go programs.\r\nOutline: [20 minutes talk]\r\nIntroduction to escape analysis in Go [8 minutes]\r\nRecap of memory allocation (stack/heap) and pointers \r\nExperiments to prove why escape analysis is important\r\nExplanation of what escape analysis is and how it works in Go\r\nHow does escape analysis affect memory allocation\r\nCommon pitfalls to watch out for [4 minutes]\r\nHow to avoid unnecessary heap allocation\r\nSome special cases for escape analysis\r\nTechniques for optimizing memory allocation in Go programs [5 minutes]\r\nHow to use the \"go build\" flag to check for escape analysis\r\nBest practices for variable declaration\r\nMeasuring the performance improvements\r\nConclusion [3 minutes]\r\nSummary of key takeaways\r\nAdditional resources for further learning\r\nOriginality:\r\nThe Go documentation provides some information about what escape analysis is and a general overview of how that works. This talk will extend those ideas and discuss why it is important to know about this optimization and the cases where it works/not works. The talk will also include some major guidelines about how to use it for the general audience to consider. \r\n\r\nTarget Audience:\r\nThis talk is aimed at Go developers of all levels who are interested in improving the performance of their applications. Whether you are a beginner just starting out with Go or an experienced developer looking to optimize your code, this talk will provide valuable insights and information. The following groups will particularly benefit from this talk:\r\nBeginner Go developers: This talk will provide a comprehensive introduction to escape analysis and its benefits, making it an excellent starting point for those new to the language.\r\nExperienced Go developers: For those familiar with Go, this talk will provide a deeper understanding of escape analysis and its implementation, as well as best practices for applying it in real-world projects.\r\nPerformance-focused developers: This talk will provide valuable information for developers who are focused on optimizing the performance of their applications. Attendees will learn about escape analysis and how it can be used to reduce the number of heap allocations and improve the performance of their applications.\r\n\r\nBackground:\r\nI am a software engineer with a year of experience in developing Go-based applications. I have experience in Go memory management and optimization, and I am passionate about helping developers write more efficient Go code.\r\nI got introduced to this topic while finding ways to optimize the Go code. I was curious about how the memory allocations in Go work and found something related to Escape Analysis for the first time. As I learned more, I found this optimization beneficial and could be utilized more.\r\nI am confident that this talk would be of great interest to the attendees of Go Conference 2023 as I will be sharing my knowledge on a topic that is crucial for developers who want to achieve maximum performance in their Go-based applications.\r\n","sessionLevel":"Intermediate","sessionType":"Challenge Session(20min)","speaker":{"fullName":"Harsh Gupta","tagLine":"Software Engineer at Money Forward, Inc.","profilePicture":"https://sessionize.com/image/d1d7-400o400o2-nGUPXtqiZS9pbXePf83k9f.jpg"}},{"id":"439725","title":"Go1.19から始めるGCのチューニング方法","roomName":"Room B","sessionId":"B9-S","description":"Go1.19のリリースにより新しくGOMEMLIMITという設定値が増えました。GOMEMLIMITが導入されたことによりヒープメモリ量の上限をユーザー側から制御できるようになりました。Go1.19以前のGCのチューニング方法はGOGCだけでしたが、GOMEMLIMITが導入されたことによりGCのチューニング方法の幅が広がりました。\r\nしかしGoは設定値を細かくいじらなくてもランタイムがある程度の最適化を行ってくれるため、一般的なAPIサーバーの開発等ではGOGCやGOMEMLIMITを意識することは少ないかと思います。そのため、これらの知見は中々溜まっておらず参考にする資料等も少ないのが現状です。\r\nそこで本セッションではGOGC・GOMEMLIMITはどんな役割かについて発表します。また内部実装を見ることで仕組みから理解することを目的に発表したいと思います。また僕自身が経験した内容を基にGCチューニングの事例から活用方法についてもお伝えします。視聴者は本セッションを見ることでGOGC・GOMEMLIMITについての知見を深めることができます。また活用事例を通してご自身のプロダクトでGCチューニングをするべきかどうかを判断することもできるようになります。","sessionLevel":null,"sessionType":"Challenge Session(20min)","speaker":{"fullName":"Takeshi Haga","tagLine":"学生","profilePicture":"https://sessionize.com/image/3069-400o400o2-T42jZSjEt5AEFFD9ZbXQua.jpeg"}},{"id":"439711","title":"Go1.20からサポートされるtree構造のerrの紹介と、treeを考慮した複数マッチができるライブラリを作った話","roomName":"Room A","sessionId":"A10-S","description":"Go1.20からはtree構造のエラーがサポートされることになりました。\r\n詳細は以下のrelease noteでも言及されています。\r\nhttps://tip.golang.org/doc/go1.20#errors\r\n\r\nもともとのproposalである https://github.com/golang/go/issues/53435 での議論をふまえ、Go1.20時点では、標準errors.Is/Asは以下のデザインとなっています。\r\n\r\n- treeを深さ優先探索する\r\n- マッチしたものがあればそこで探索を打ち切り結果を返す\r\n- tree上のすべての枝がIs/Asにマッチすることを保証しない\r\n\r\nですが、tree構造とのマッチ判定はユースケースによってはさらにいくつかの要求が考えられます。たとえば\r\n\r\n- 分岐した全枝についての一致を確認するより厳密な同一性判定\r\n- treeのなかで一致した要素をすべて取り出す\r\n\r\nなどです。このようなより柔軟な要求に対して、現状の標準errors.Is/Asを利用することはできません。\r\n\r\n今回は元となった \"errors: add support for wrapping multiple errors\" proposalでの議論をおさらいしつつ、標準errorsでは実現できないいくつかの要求についてマッチ処理を実装したので紹介します。\r\nまた、実装中に感じた課題などについても触れれればと思います。\r\n\r\n実装したレポジトリは以下です。\r\nhttps://github.com/convto/errortree\r\n\r\ntree構造のerrはGo1.20から追加された新しい概念であり、整理のために多くの実験や議論が必要だと思っています。\r\nこの発表で該当の議論に関心を持つ方が増えれば嬉しいです。","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"奥村 優哉","tagLine":"株式会社LayerX","profilePicture":"https://sessionize.com/image/09e1-400o400o2-4267faff-b45c-4867-868f-3dcca0492d3e.jpg"}},{"id":"438792","title":"Goのtestingパッケージにコミットした話（並列テストの解説を交えて）","roomName":"Room B","sessionId":"B10-S","description":"Goのtestingパッケージにコミットした体験記とその際に学んだ並列テストの振る舞いの解説。\r\n\r\nコミット内容：\r\nT.SetenvとT.Parallelの組み合わせを禁止する処理の考慮漏れの対応。\r\n\r\n並列テストの振る舞いの解説：\r\nなぜ並列テストで環境変数の利用を禁止する必要があるのかを説明するために並列テストがどのような振る舞いをしているのかを解説します。\r\n\r\nより具体的には以下のテックブログにまとめてある内容のお話をしたいと思っております。\r\nhttps://tech.mirrativ.stream/entry/2022/12/22/171137\r\n\r\n\r\n#チャレンジセッションを選択した理由\r\n\r\nGoでの登壇が初めての方\r\n→ 初めてです\r\n\r\nGoに関連したプロジェクトに貢献した方\r\n→ testingパッケージにコミットしました\r\n\r\n\r\n# 言語\r\n\r\n日本語","sessionLevel":"beginner","sessionType":"Challenge Session(20min)","speaker":{"fullName":"藤井 脩紀","tagLine":"株式会社ミラティブ","profilePicture":"https://sessionize.com/image/52d9-400o400o2-E9AFzKJdKS5kHfhenacagv.jpg"}},{"id":"439694","title":"Goのデバッグ用ロガーの開発を通して得た, デバッグとgoパッケージに関する知見","roomName":"Room A","sessionId":"A11-S","description":"[Elevator Pitch]\r\nGoでデバッグをする場合, 基本的にはDelve, GDB, ロギングの3択になります. DelveやGDBによるデバッグは便利ですが複数の変数情報を高速に得ることは困難であり, この用途にはロギングが適しています. しかし, デバッグ用に追加したロギング用のコードを消し忘れ, 実行速度の低下や業務用のコードにおける機密情報のログ出力等の問題を引き起こす可能性があります. これらの問題に対処するべく, 私はGoの静的解析および動的解析によって変数情報等を表示可能で, コミット時に自動的に削除されるデバッグ用のロガーdlを開発しました. 本セッションでは, 前述したGoにおける3種類のデバッグ方法の利点および欠点ならびにdlの開発を通して得たgo/ast等のgoパッケージに関する知見をご紹介します.\r\n\r\n[Main Description]\r\n開発において, 想定外の挙動をした際にデバッグをした経験がある方は多いのではないでしょうか? Goでデバッグをする場合, 基本的にはDelve[1], GDB[2], ロギングの3択になります. Delve[1]はサードパーティー製のGo用デバッガであり, 実行時の変数やスタック情報の表示や上書き, goroutineの情報取得等ができます. また, リモードデバッグを有効にすることで, VS CodeやGoLandなどのエディタやIDEに組み込んでGUI上でデバッグすることもできるため, 開発時に重宝します. GDB[2]はDelve[1]と似たデバッガで, gef[5]やpeda[4], pwndbg[6]等のGDBスクリプトにより, 低レイヤを対象としたデバッグを円滑に行うことができます. しかし, Go Blogの記事[3]に記載されているように, Goプログラムの構造を理解していないため誤った結果を表示する場合もあります. また, Delve[1]やGDB[2]はある1点の状態を詳しく得ることは得意ですが, 複数の変数情報等をまとめて高速に得ることは不得手です. したがって, 手軽に複数の変数情報等をまとめて高速に得る用途にはロギングが適しています.\r\n\r\nGoのロギングには, builtinパッケージのpanic, print, println, fmtパッケージやlogパッケージの各種関数およびメソッド, サードパーティー製のglog[7], Logrus[8], zap[9]等のロガーが利用できます. また, logr[10]が提供するinterfaceを満たすロガーを利用することで, それぞれのロガーを手軽に切り替えることもできます. これにより, Delve[1]やGDB[2]と違い, 複数の変数情報等をまとめて高速に得ることができます. しかし, デバッグ用に追加したロギング用のコードを消し忘れ, 実行速度の低下や業務用のコードにおける機密情報のログ出力等の問題を引き起こす可能性があります. 実際に, 私もインターンシップ先のリポジトリに対して余分なロギング用のコードを追加し, レビュー漏れで本番コードに紛れ込んでしまった経験があります．\r\n\r\nそこで, 私はGoの静的解析と動的解析によって変数情報等を表示でき，コミット時に自動的に削除されるデバッグ用のロガーdl( https://github.com/task4233/dl )を開発しました. Design Docsはこちら( http://bit.ly/3XGdtyF )です. dlは変数とその型情報, 変数が利用されているコードの行数を表示する機能とコミット時に自動的に削除される機能を提供します. これらの機能は, Goのgo/token, go/parser, go/astパッケージ等を用いた静的解析やruntimeパッケージを用いた動的解析を活用することで実現しています. また, dlは前述したlogrのinterfaceを満たしているロガーであればラップすることができ, 既存のロガーを変更することなく容易に導入することができます. 私が調査した中では, これらの機能を全て備えたロガーは他に存在しませんでした(2023/01/30現在).\r\n\r\n本セッションでは, 前述したGoにおける3種類のデバッグ方法の利点および欠点ならびにdlの開発を通して得たgo/ast等のgoパッケージに関する知見をご紹介します. 過去のGo ConferenceでGDB[2]に関する講演[11]がありましたが, これとは異なる切り口の内容なので差分はあると考えています.\r\n\r\n[1] go-delve/delve: https://github.com/go-delve/delve \r\n[2] GDB: The GNU Project Debugger: https://www.sourceware.org/gdb/ \r\n[3] Debugging Go Code with GDB: https://go.dev/doc/gdb \r\n[4] hugsy/gef: https://github.com/hugsy/gef \r\n[5] longld/peda: https://github.com/longld/peda \r\n[6] pwndbg/pwndbg: https://github.com/pwndbg/pwndbg \r\n[7] golang/glog: https://github.com/golang/glog \r\n[8] Sirupsen/logrus: https://github.com/Sirupsen/logrus \r\n[9] uber-go/zap: https://github.com/uber-go/zap/ \r\n[10] go-logr/logr: https://github.com/go-logr/logr \r\n[11] Debugging Go Code with GDB:https://speakerdeck.com/kaneshin/debugging-go-code-with-gdb\r\n","sessionLevel":null,"sessionType":"Challenge Session(20min)","speaker":{"fullName":"Takashi Mima","tagLine":"Mercari, inc.","profilePicture":"https://sessionize.com/image/10ec-400o400o2-Rq1dfj5AXWHc2MsCBGd2yf.jpeg"}},{"id":"439829","title":"Goのメモリ管理","roomName":"Room B","sessionId":"B11-S","description":"Goはいまや多くのシステムクリティカルな製品を支える言語として広く採用されていますが、その内部構造に関する理解はまだ広く認識されているとはいえません。\r\n本セッションでは、Goランタイムがどのようにメモリ管理を実現しているかをランタイムレベルから解説します。それを踏まえて、その仕組み故に気をつけなければいけないユースケースなどを深堀りし、実際にどのように解決するかを解説していきます。\r\n本セッションはLinuxの知識なども必要となりますが、セッションを終える頃にはGoのメモリ管理について大まかな理解が得られることでしょう。","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"山口 能迪","tagLine":"グーグル合同会社 デベロッパーリレーションズエンジニア","profilePicture":"https://sessionize.com/image/88a2-400o400o2-BtrsNVefpV9wcsDmEh64Ce.jpg"}},{"id":"439678","title":"Goはブロックチェーン領域でなぜ使われ、どのように活躍しているのか","roomName":"Room A","sessionId":"A12-S","description":"ブロックチェーンの領域では、分散型金融システムEthereumをはじめ、多くの場面でGo言語が活躍しています。\r\nこのセッションでは、ブロックチェーン領域でGoがなぜ利用されるのかを解説し、具体的にどのようにブロックチェーンの技術を支えているのかを実際のコードを見ながら紹介します。\r\nブロックチェーン領域でのGoの使われ方を学ぶことで、Goの特性を知り、分野を問わずGoを活用する際の知見となることを想定しています。また、このセッションがGoを通してブロックチェーンの技術を学ぶきっかけとなり、聴講者にブロックチェーン技術へ興味を持ってもらうことを期待しています。\r\n\r\n対象とする聴講者\r\n・Goの強みや活用事例に興味がある人\r\n・ブロックチェーンの仕組みやこの領域での技術選定に興味がある人\r\n\r\nセッションの目的\r\n・ブロックチェーン領域でのGoの利用事例から、Goがもつ強みを知り、Goによる技術選定全般に役立ててもらう\r\n・Goを通してブロックチェーンの技術を学ぶ足がかりを提供する\r\n\r\n扱うトピック\r\n・ブロックチェーンの概要について\r\n　・ブロックチェーンがあつかう課題や、P2P通信や暗号技術などブロックチェーンを支える技術の概要を説明します\r\n・ブロックチェーンで活躍するプログラミング言語\r\n　・ブロックチェーンにはどのような要件があり、なぜGoが選ばれるのかを解説します\r\n　・近年、Rustの採用事例も増えており、GoとRustの比較についても触れられればと思います\r\n・どのようにGoが使われているのか\r\n　・Ethereumなどの有名OSSでの活用事例を紹介し、具体的にどのように(どのようなコードで、何のパッケージを使って)ブロックチェーンの技術を実現しているかを解説します","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"uji","tagLine":"MoneyForward, Inc.","profilePicture":"https://sessionize.com/image/214a-400o400o2-PgPv7EW47xwAY38gj69NSt.jpg"}},{"id":"430443","title":"High performance regular expressions using RE2 and WebAssembly, no cgo required","roomName":"Room B","sessionId":"B12-S","description":"Go’s regexp package works great for most use cases but performance drops for complex expressions such as those in security firewalls. This presentation will show how go-re2 uses RE2, a C++ library, and wazero to improve performance of regex for any Go app, even where cgo is not available.","sessionLevel":"Intermediate","sessionType":"Short Talk(20min)","speaker":{"fullName":"Anuraag Agrawal","tagLine":"Software Engineer - OSS Enthusiast","profilePicture":"https://sessionize.com/image/b694-400o400o2-BXaeLLEFE1HbgWSzGVAESb.jpg"}},{"id":"439818","title":"net/http/httptest.Server のアプローチをテスト戦略に活用する","roomName":"Room A","sessionId":"A13-S","description":"net/http/httptest.Serverは、 `go test` 実行時に実際にHTTPサーバを起動することでクライアント-サーバ間のテストをシンプルに実現します。\r\n\r\nこのnet/http/httptest.Serverのアプローチは、WebアプリケーションのテストであればWebアプリケーションを構成するレイヤーの外側からHTTPリクエストを送信するテストができますし、HTTPクライアントのテストであればHTTPクライアントを構成するレイヤーの外側にスタブサーバを簡単に用意できます。しかも `go test` の中で完結しており、テストサイズによる分類における他のミディアムテストと比べても安定しているといえるアプローチです。\r\n\r\n発表者は、プロダクトの新規開発時のアーキテクチャの未完状態に対抗する手段として、net/http/httptest.Serverのアプローチをより広くテストに活用する方針を取りました。\r\nこれは、アプリケーションの外側を活用したのテストを厚くすることで、アプリケーション内部のアーキテクチャ変更に強くすることを目的としています。\r\n\r\n本発表では、「net/http/httptest.Server のアプローチ」のメリットやデメリット、そのデメリットの緩和策、実際の効果などを紹介したいと思います。\r\n","sessionLevel":null,"sessionType":"Short Talk(20min)","speaker":{"fullName":"Ken'ichirou Oyama","tagLine":"GMOペパボ株式会社 技術部技術基盤チーム プリンシパルエンジニア","profilePicture":"https://sessionize.com/image/e84a-400o400o2-911tTYPc9QbdLsgw5ALRjP.png"}},{"id":"440322","title":"Nxで一歩進んだGoモノレポを構築する","roomName":"Room B","sessionId":"B13-S","description":"近年、Go界隈でモノレポの需要は増えています。Goでモノレポのビルド環境を構築するといえば、まずBazelを連想すると思いますが、Bazelは学習コストが高さが難点です。ただ、ビルドタスクの依存関係の解決、リモートキャッシュ、分散ビルド、といったBazelの機能はモノレポを構築するにあたって魅力的です。そこで、Bazelと類似の機能を備えつつも扱いが楽なNxを紹介します。ある程度の規模のモノレポでも通用するタスクランナーを利用したいがBazelは難しいという方々には、Nxは一考に値します。","sessionLevel":"Intermediate","sessionType":"Short Talk(20min)","speaker":{"fullName":"Michitoshi Tabata","tagLine":"ANDPAD Inc","profilePicture":"https://sessionize.com/image/c84a-400o400o2-MQSUhiatJdnkLZB7QsjQEY.jpg"}},{"id":"439681","title":"sync.Mutexの仕組みを理解する","roomName":"Room A","sessionId":"A14-S","description":"syncパッケージとは相互排他ロックなどの基本的な同期プリミティブを提供するパッケージです。\r\nその中の一つにsync.Mutexというものが存在します。\r\nsync.Mutexはgoroutineの排他制御を行うための機能です。\r\nsync.Mutexの使い方やごく簡単なサンプルコードは数多く存在しますが、sync.Mutexの内部的な実装を解説した記事は現時点では2桁もありません。\r\nそこで、本セッションでは、排他制御の定義、sync packageの概要について説明した後に、sync.Mutexおよび、Lock、Unlockメソッドに着目し内部実装レベルでコードリーディングし、理解を深めていきます。\r\n理解を深めていくにあたって、次世代UNIXとして開発されていた分散OSであるPlan 9の存在は欠かせません。\r\nそこで、ベル研究所の元メンバーであり、Plan 9に携わったのち、現Goチームで開発を行うRuss Cox氏の書いたSemaphore in Plan 9の論文を参考にします。\r\n上記の論文を引用しながら、sync.Mutexの仕組みを原理原則から整理して話します。\r\nセッションの聴講者は、sync.Mutexの理解および、実装を読むにあたり必要なGoのランタイムパッケージ、スケジューラ、go:linkname ディレクティブといったGoのエコシステムの仕組みについても学ぶことができます。","sessionLevel":null,"sessionType":"Challenge Session(20min)","speaker":{"fullName":"Yoshiki Fujikane","tagLine":"CyberAgent.inc","profilePicture":"https://sessionize.com/image/d5d0-400o400o2-HM2pYcFSDPHTRjBiThamQ3.png"}},{"id":"439782","title":"ネットワークコントローラ実装で学ぶ、Goクライアントサーバシステムの作り方","roomName":"Room B","sessionId":"B14-S","description":"Goは並行処理を簡単に実現可能な強みを持つため、複数のクライアントと同時並行かつ中央集権的に情報を交換するサーバシステムを、コードの可読性を保ったまま実装することが可能な言語です。我々は、ネットワーク分野でもこの強みを活かすことができないか試行錯誤しています。\r\n\r\nクライアントサーバシステムの例として、ネットワーク機器のパス管理を行うPCEという仕組みがあります。キャリアのように多くのルータで構成される大規模ネットワークにおいてパス管理は重要な要素ですが、誰もが手軽に試験・運用できるPCEはありませんでした。そこで我々は、Goの特性を活かしてPCEをOSSとして実装しました。その結果、誰でも手軽に試験できるようになりました。\r\n\r\n本セッションでは、Go初学者であった我々がネットワークプロトコルやサーバ機能をOSSとして実装する中で理解したことについて、公開済のコードを用いて紹介します。\r\n具体的には、\r\n- goroutine と channel を用いたサーバのセッション管理 \r\n- gRPC によるサーバ情報取得/更新のためのAPI提供\r\n- interface の定義・実装による標準ライブラリ有効活用や実装の隠蔽\r\nについて説明します。\r\n\r\n本セッションの内容を取り込み開発することで、Go らしいネットワークプロトコルやサーバの実装が可能になります！","sessionLevel":"beginner","sessionType":"Challenge Session(20min)","speaker":{"fullName":"Motoki Takenaka","tagLine":"NTT Communications Corp. ","profilePicture":"https://sessionize.com/image/b2d3-400o400o2-Bioy5opi87gWckBu2VzZ3i.JPG"}},{"id":"438517","title":"GCにおけるパフォーマンス改善","roomName":"Room A","sessionId":"LT1","description":"日に2億件をさばくGoで書かれた広告配信サーバーにおいて\r\nGoのversionを1.17から1.19に上げた際にレイテンシとCPUを増加させることなく、3〜4割のメモリ使用量を抑えることに成功しました。\r\n\r\nそこで本セッションでは、実際の計測値を交えながらhttps://go.dev/doc/gc-guide をベースにGoのGCのしくみについて説明いたします。","sessionLevel":"all","sessionType":"LT(5min)","speaker":{"fullName":"Toyohito Murooka","tagLine":"Speee, Inc. Programmer","profilePicture":"https://sessionize.com/image/8102-400o400o2-9a99d4f7-70f0-4e18-93de-3a3f2fd62d0e.jpg"}},{"id":"439821","title":"Goで並行処理を用いた画像処理を実装した話","roomName":"Room A","sessionId":"LT2","description":"Goで不足している画像処理を実装しました。\r\nその際に並行処理を用いることによるパフォーマンス改善の検証を行いました。\r\n\r\nGoには他の言語と同様にオープンソースの画像処理ライブラリがあります。しかし主要な画像処理手法は用意されていますが、Pythonと比較すると機能が充実していません。そのため実務で画像解析の処理を書く際に既存のライブラリにない手法は自分で実装を行いました。\r\n\r\n実装した処理は画像内で指定した任意の４点を囲う領域に対してモザイク処理を行う処理です。\r\n実装の際に画像内の各ピクセルにアクセスする部分に対し並行処理を用いました。並行処理によりどれくらいパフォーマンスが改善されるかを検証し、画像処理に並行処理を用いることの有用性を確認します。","sessionLevel":"all","sessionType":"LT(5min)","speaker":{"fullName":"Yuya Hiramatsu","tagLine":"株式会社Newbees","profilePicture":"https://sessionize.com/image/fb79-400o400o2-Gre96Pq8oUujmnkUisFeDG.png"}},{"id":"439985","title":"Goによるプロセス管理とシグナルハンドリング","roomName":"Room A","sessionId":"LT3","description":"Goの標準パッケージである`os`を用いたgoroutineの管理、プロセスが停止される際のシグナルのハンドリングについて具体例とともに紹介します。\r\n特にコンテナで稼働しているWebサーバにおいてはシグナルを考慮した上で実装を行う必要があります。シグナルについて全く考慮していない場合、コンテナが終了するタイミングで同時に内部で動いているプロセスもキルされてしまい、中途半端な状態で処理が終了してしまうことがあります。\r\n\r\n実際の発表の際は、弊社のコーディング試験サービスを例に挙げ、考慮しない場合にどのような問題が生じるのか、とともに紹介します。\r\nこのLTを通して、Goにおけるシグナルのハンドリングに関する基本について学ぶことができます。","sessionLevel":null,"sessionType":"LT(5min)","speaker":{"fullName":"Yuichi Ito","tagLine":"株式会社ハイヤールー","profilePicture":"https://sessionize.com/image/68a8-400o400o2-7hp77VN5xUxQGuqYqWdGaR.jpeg"}},{"id":"439806","title":"Information Schemaから自動生成する型付きORM spannent","roomName":"Room A","sessionId":"LT4","description":"GoでRDBを使う際には標準のdatabase/sqlがありますが、ORMを使用することもあります。\r\nMySQLやPostgreSQLのような広く普及したDBにはSQLドライバが存在したり、対応したORMが多数存在します。\r\nしかしNewSQLのような新しいDBにはそれらが存在しないことも多いです。\r\n\r\nまたGoはパターン化されたコードを自動生成する機構を言語の標準機能だけで作りやすい特徴があります。\r\n特にORMの領域では近年有名なEntというパッケージがあります。\r\nEntではGoでテーブル定義を行い、各テーブル・カラムに対応した型付きのコードを自動生成する特徴があります。\r\n自動生成されたコードは基本的にメソッドチェーンで記述することができます。また\r\nマイグレーション機能も存在するため、Goのテーブル定義をDBに反映することもできます。\r\nGormや他の自動生成ではないORMと比較し、存在するテーブル・カラム名や型がコード上に定義されているため、DDLを参考せずともGo上だけでテーブル定義が把握できることや、名前や型を間違えにくいことが利点です。\r\nしかしEntも対応したNewSQLの種類は少ないです。\r\n\r\nそこで今回はNewSQLの一種であるGoogle Cloud SpannerのORMを自動生成しました。\r\n生成されるコードは上述の利点からEntを参考にしています。\r\nまた最小限の機能を持つORMとしたかったため、マイグレーション機能は持たせていません。\r\nそのためテーブル定義はGoで定義するのではなく、Information Schemaから読み取ることで、実際のDBのテーブル定義との同期を図っています。\r\n\r\n本セッションを聴くことで、Spanner以外にもORMをGoで作成する際の実装ヒントを得ることができます。\r\n例えばチームによってSnowflakeやBigQueryのORMを作成したいモチベーションがある場合、参考にすることができます。\r\nまたORMに限らずテーブル定義所の生成やテストコードの生成等のGoで自動生成する強みとアイデアを知ることが可能です。","sessionLevel":null,"sessionType":"LT(5min)","speaker":{"fullName":"Yuki Kume","tagLine":"株式会社サイバーエージェント","profilePicture":"https://sessionize.com/image/02f3-400o400o2-VJuim1UPZfjtw9fhVKfVLn.png"}},{"id":"440263","title":"SREのチーム共通言語をGoにした話","roomName":"Room A","sessionId":"LT5","description":"私の所属する会社のSREチームは多くがインフラ系出身のメンバーとなっています。サービス運用に関するツールは各メンバーが得意の言語で実装されており知識の共有が行えなかったり得意言語以外のコードレビューや修正に時間がかかってしまうという課題がありました。そういった課題を解決すべく我々はチームの共通言語としてGoを選択しました。本LTでは「共通言語になぜGoを選択したのか」や「どのようにしてGoを学習し共通化していったのか」「Goを選んでよかったこと」といった内容についてお話しします。","sessionLevel":null,"sessionType":"LT(5min)","speaker":{"fullName":"Watanabe Ryuichi","tagLine":"GMOペパボ株式会社","profilePicture":"https://sessionize.com/image/0619-400o400o2-RvWsDQBeyEoGnNfV1mhneh.png"}},{"id":"439857","title":"TinyGo で作る自作キーボードの世界","roomName":"Room A","sessionId":"LT6","description":"プログラムを書くにはキーボードがほぼ必須となります。\r\n自分好みのキーボードを探す時、キーボード自体を自作するという選択肢があります。\r\nしかし現状の自作キーボードのファームウェアの多くは C 言語で作成されています。\r\nGo Conference に参加されている人は Go で自作キーボードのファームウェアが書けると嬉しいのではないでしょうか？\r\n\r\nこのトークでは、 TinyGo を使って自作キーボードを作った記録を共有します。\r\nTinyGo を使うと Go の文法で自作キーボードのファームウェアを書くことができます。\r\nC 言語製のメジャーなファームウェアのように機能は多くないですが、欲しい機能は自分で追加することができます。\r\n\r\nTinyGo で楽しい自作キーボードライフを。","sessionLevel":null,"sessionType":"LT(5min)","speaker":{"fullName":"Masaaki Takasago","tagLine":"tinygo.org","profilePicture":"https://sessionize.com/image/cb2f-400o400o2-GZKDhuBrarSHZ5VYPENWua.png"}},{"id":"439673","title":"ゲームの抽選ロジックにGenericsを使ってみたら開発が楽になった話","roomName":"Room A","sessionId":"LT7","description":"本セッションではGoにおけるゲームの抽選ロジック紹介と、対象ロジックへのGenerics導入事例について紹介します。\r\n\r\nゲーム開発ではランダムドロップやガチャといった抽選を必要とする機能が多く存在するため、Interfaceを利用し各抽選ロジックの共通化を行ったのでその設計について紹介します。\r\n\r\nまた、Go1.18でGenericsが導入された後は、上記ロジックにGenericsを適用することで開発効率が向上したため、Generics導入前後の事例についても共有します。\r\n\r\n本セッションを通じて、Goにおけるゲーム開発やGenerics活用の手助けになれば幸いです。","sessionLevel":"beginner","sessionType":"LT(5min)","speaker":{"fullName":"朝倉 信晴","tagLine":"株式会社QualiArts","profilePicture":"https://sessionize.com/image/b62f-400o400o2-RaJTyeWev3gmSxWBXQyPTM.jpg"}},{"id":"439300","title":"列挙型の作り方を再考する","roomName":"Room A","sessionId":"LT8","description":"公式ドキュメントのEffective Goで推奨されているように、iotaを使ったやり方で列挙型と列挙子を表現すると、\r\n- 列挙型が一つ存在し\r\n- その列挙型を持つ定数が複数存在する\r\nというような構成になる。\r\n\r\n列挙子の一覧を出すだけならこのやり方は確かに手軽だが、それぞれの列挙子に更に何らかの挙動を定義するとなると、\r\nメソッドごとに「既知のこの列挙子についてはこういった処理を行う」という形の条件分岐が登場することになり、\r\nこれはすなわち、列挙子を追加することになったら、そのたびにすべてのメソッドが影響を受けてしまう、ということを意味する。\r\n\r\nこのような問題点を受け、\r\n- 列挙型を表すインターフェイスを一つ定義し\r\n- 列挙子ごとに、列挙型のインターフェイスを実装した型を定義する\r\nというような構成にしてみると、\r\n\r\n- 特定の列挙子が持つ挙動はその列挙子の周りに集まり（凝集度の向上）\r\n- ポリモーフィズムで条件分岐を消すことができ\r\n- 既存のコードに触らずに列挙子を新たに追加することができる（Open-Closed Principleの体現）\r\nといったメリットが得られるのである。\r\n\r\nという内容を、コードを持って説明します。","sessionLevel":"all","sessionType":"LT(5min)","speaker":{"fullName":"Takumi Ichimonji","tagLine":"株式会社Voicy","profilePicture":"https://sessionize.com/image/cbc0-400o400o2-TGsz9wiFt3uMfhUqx7Ri21.jpg"}}]},"__N_SSG":true}