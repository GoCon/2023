{"pageProps":{"title":"列挙型の作り方を再考する","roomName":"Room A","sessionId":"LT8","description":"公式ドキュメントのEffective Goで推奨されているように、iotaを使ったやり方で列挙型と列挙子を表現すると、\r\n- 列挙型が一つ存在し\r\n- その列挙型を持つ定数が複数存在する\r\nというような構成になる。\r\n\r\n列挙子の一覧を出すだけならこのやり方は確かに手軽だが、それぞれの列挙子に更に何らかの挙動を定義するとなると、\r\nメソッドごとに「既知のこの列挙子についてはこういった処理を行う」という形の条件分岐が登場することになり、\r\nこれはすなわち、列挙子を追加することになったら、そのたびにすべてのメソッドが影響を受けてしまう、ということを意味する。\r\n\r\nこのような問題点を受け、\r\n- 列挙型を表すインターフェイスを一つ定義し\r\n- 列挙子ごとに、列挙型のインターフェイスを実装した型を定義する\r\nというような構成にしてみると、\r\n\r\n- 特定の列挙子が持つ挙動はその列挙子の周りに集まり（凝集度の向上）\r\n- ポリモーフィズムで条件分岐を消すことができ\r\n- 既存のコードに触らずに列挙子を新たに追加することができる（Open-Closed Principleの体現）\r\nといったメリットが得られるのである。\r\n\r\nという内容を、コードを持って説明します。","sessionLevel":"all","sessionType":"LT(5min)","recordingUrl":null,"slideUrl":null,"speaker":{"fullName":"Takumi Ichimonji","profilePicture":"https://sessionize.com/image/cbc0-400o400o2-TGsz9wiFt3uMfhUqx7Ri21.jpg","bio":"Goでツアー予約システムや物流情報システムの開発を経験し、2023年にVoicyに入社。コードの可読性や保守性を考えるのが好きです。","tagLine":"株式会社Voicy","twitterUserName":null}},"__N_SSG":true}